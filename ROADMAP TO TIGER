-Estudiar applicatives.
-Reesciribir los levels como se me antoje.
-Recordar que callExp TOMA EL LEVEL... pero en mi implementación no lo usa.
-Puede haber un record con dos campos del mismo nombre, ¿Que pasaría en tal caso?.
-Meterse con el canonizador de código intermedio, entender que hace y si me sirve.
-Por alguna razon, los accesos no tienen offsets de wSz, se incrementan de a 1. Recordar. Revisar con el canonizador.
-Hacer que todo falle lindo, con errores claros.
-Emprolijar y hacer un label de esta etapa, para cerrar codigo intermedio. 
-Avanzar con el compilador hasta terminarlo.


----------------------
Chanchada para detectar los ciclos ilegales en las definiciones de tipo. Complejidad n^2.

tengo un grafo dado por (simbolo, tipo) donde tipo puede hacer referencia a un simbolo (otro tipo).

no tiene que haber ciclos partiendo de ningún nodo.

Me quedo con los tipos que pueden dar bucles mal hechos. (los TName)

hayCiclo [(a, ref b):ts] ls = b en ls || buscarCiclos (hacerHead b ts) (a:ls)
hayCiclo [] ls = False
 where hacerHead b ts = la lista ts con el nodo b primero. o una lista vacía si ts es vacía.

se hace:

hayCiclos ts = foldr (\bl bb -> bl || bb) False listaCiclos
 where listaCiclos = map (\(a,ref b) -> hayCiclo (hacerHead a ts) []) ts -- n^2
--------------------------------