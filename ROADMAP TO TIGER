-Avanzar con el compilador hasta terminarlo.
Fechas:
15 de Noviembre: Escupiendo código, ya echo el emisor de código con llamadas incluidas. Hacer procEntryExit, prologo y epílogo de funciones
16 de Noviembre: Leido liveness y allocation.
20 de Noviembre: Hecho liveness
1 de Diciembre: Hecho allocation
8 de Diciembre: Armado, hablar para entregar
15 de Diciembre: Compilador TERMINADO. Completito.

Recordar:
-Estamos traduciendo EXPRESIONES de la forma (1 < 3) como Cx. Para esto tuvimos que modificar el seq
 para que reciba el caso de Cx. Esto puede traer problemas mas adelante, recordarlo por las dudas.
-Por alguna razon, los accesos no tienen offsets de wSz, se incrementan de a 1. Recordar. ·    
-Puede haber un record con dos campos del mismo nombre, ¿Que pasaría en tal caso?.
-Meterse con el canonizador de código intermedio, entender que hace y si me sirve.

----------------------
Chanchada para detectar los ciclos ilegales en las definiciones de tipo. Complejidad n^2.

tengo un grafo dado por (simbolo, tipo) donde tipo puede hacer referencia a un simbolo (otro tipo).

no tiene que haber ciclos partiendo de ningún nodo.

Me quedo con los tipos que pueden dar bucles mal hechos. (los TName)

hayCiclo [(a, ref b):ts] ls = b en ls || buscarCiclos (hacerHead b ts) (a:ls)
hayCiclo [] ls = False
 where hacerHead b ts = la lista ts con el nodo b primero. o una lista vacía si ts es vacía.

se hace:

hayCiclos ts = foldr (\bl bb -> bl || bb) False listaCiclos
 where listaCiclos = map (\(a,ref b) -> hayCiclo (hacerHead a ts) []) ts -- n^2
--------------------------------
Manejo de levels. Simplificado.

El frame se rellena haciendo el análisis semántico de una función. 
Este análisis semántico da el código intermedio del cuerpo.
El level tiene que estar disponible al momento de hacer el código intermedio de una función.

Se lleva en el estado, con dos campos.

level: El level actual (una lista de frames con toda la anidación que estamos teniendo)
actualLevel: El número de level actual. Inutil, se puede leer de la lista porque nunca la recorremos.

Cuando se guarda la funEntry, esta lleva el Level con su frame y todos los de sus padres, para poder
calcular static links.

Cuando se genera el código intermedio de la función, el FRAME queda guardado en el fragmento.

Es argumento a la hora de generar el código intermedio de una llamada a función. No se por qué, no se usa.

data LevelI = MkLI {getFrame' :: Frame, getNlvl' :: Int}
  deriving Show

type Level = [LevelI]

newLevel :: Level -> Symbol -> [Bool] -> Level
newLevel [] s bs                 = [MkLI (newFrame s bs) 0]
newLevel ls@(MkLI _ lvl :_) s bs = (MkLI (newFrame s bs) (lvl+1)) : ls

getParent :: Level -> Level
getParent []     = P.error "No fuimos del outermost level"
getParent (_:xs) = xs

outermost :: Level
outermost = [ MkLI (newFrame (pack "_undermain") []) (-1) ]
---------
Mecanismo para la selección de instrucciones.

Lo ideal, creo sería hacer un selector dinámico. Pero no se me termina de ocurrir como.